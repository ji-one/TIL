## 타입 변환

원시 값은 변경 불가능한 값이므로 변경할 수 없다. 따라서 타입 변환이란 기존 원시 값을 사용해서 다른 타입의 새로운 원시 값을 생성하는 것이다. 

표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 하는데 이를 `암묵적 타입 변환`, `타입 강제 변환`이라 한다. 암묵적 타입 변환은 기존 변수 값을 재할당해서 변경하는 것이 아니다. **자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자의 값을 암묵적 타입 변환해 새로운 타입의 값을 만들어 단 한 번 사용하고 버린다.** 



```javascript
var x = 1;
// 암묵적 타입 변환 
var str = x + ''; // 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열 생성
console.log(typeof str) // string
console.log(typeof x) // number
```

<br/>

## 암묵적 타입 변환

```javascript
1 + '2' // "12"
'10' * 1 // 10
!0 // false
```

위 예제에서 `+ 연산자`는 피연산자 중 하나 이상이 문자열이므로 `문자열 연결 연산자`로 동작한다. 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 `암묵적 타입 변환`한다.

<br/>

### 문자열 타입으로 변환

```javascript
-1 + '' // "-1"
-Infinity + '' // "-Infinity"
true + '' // "true"
null + '' // "null"
undefinded + '' // "undefinded"
({}) + '' // "[object Object]"
Math + '' // "[object Math]"
[] + '' // ""
[10, 20] + '' // "10,20"
(function(){}) + '' // "function(){}"
Array + '' // "function Array() {[native code]}"
```

<br/>

### 숫자 타입으로 변환

```
1 - '1' // 0
1 * '10' // 10
1 / 'one' // NaN

+'' // 0
+'1' // 1
+true // 1
+null // 0
+undefinded // NaN
+{} // NaN
+[] // 0
+[10, 20] // NaN
```

자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 피연산자를 숫자 타입으로 변환할 수 없는 경우에는 NaN이 된다.

또한 `+ 단항 연산자`는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다. 변환되지 않는 경우 NaN이 된다.

<br/>

### 불리언 타입으로 변환

자바스크립트 엔진은 불리언 타입이 아닌 값을 참으로 평가되는 값 또는 거짓으로 평가되는 값으로 구분한다. 즉 불리언 값으로 평가되어야 할 문맥에서 참으로 평가되는 값을 true로, 그렇지 않으면 false로 암묵적 타입 변환된다.

아래의 값들은 `false`로 평가된다. `{}`, `[]`는 `true`로 평가된다.

- false
- undefined
- null
- 0, -0
- NaN
- ''

<br/>

## 명시적 타입 변환

### 문자열 타입으로 변환

- new 연산자 없이 String 생성자 함수 호출
  - `String(1); // "1"`
- Object.prototype.toString 메서드 사용
  - `(1).toString(); // "1"`
- 문자열 연결 연산자 이용
  - `1 + ''; // "1"`

<br/>

### 숫자 타입으로 변환

- new 연산자 없이 Number 생성자 함수 호출

  - `Number('0'); // 0`

- parseInt, parseFloat 함수 사용 (문자열만 변환 가능)

  - `parseInt('0');`

- `+` 단항 산술 연산자 이용

  - `+'0'; // 0`

- `*` 산술 연산자 이용

  - `'0'*1 // 0`

  <br/>

### 불리언 타입으로 변환

- new 연산자 없이 Boolean 생성자 함수 호출
- ! 부정 논리 연산자 두 번 사용

<br/>

## 단축 평가

```javascript
'Cat' && 'Dog' // "Dog"
```

`논리곱 연산자(&&)`는 좌항에서 우항으로 평가된다. 위 예제에서 'Cat'은 true로 평가된다. 논리곱 연산자이므로 이 경우 두 번째 피연산자까지 평가해봐야 한다. 즉 두 번째 피연산자가 예제의 논리곱 연산자 표현식의 평가 결과를 결정한다. 이때 **논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자인 문자열 "Dog"를 그대로 반환한다**.

```javascript
'Cat' || 'Dog' // "Cat"
```

 위 예제에서는 논리 연산의 결과를 결정한 "Cat"을 반환한다.



이처럼 논리곱 연산자(&&)와, 논리합 연산자(||)는 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지않고 그대로 반환한다. 이를 `단축 평가`라 하며 **표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 의미한다.**

<br/>

### 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티 참조할 때

객체를 가리키기 기대하는 변수의 값이 객체가 아니라 `null` 또는` undefined`인 경우 객체의 프로퍼티를 참조하면 `타입 에러`가 발생한다. 에러를 발생시키지 않기 위해 단축 평가를 사용할 수 있다.

```
var el = null;
var value = el && el.value; // null
```

<br/>

### 함수 매개변수에 기본값 설정할 때

함수 호출 시 인수를 전달하지 않으면 매개변수에 `undefined`가 할당된다. 이를 단축 평가를 통해 에러를 발생시키지 않을 수 있다.

```
function foo(str){
	str = str || ''; // 단축 평가를 사용한 매개변수 기본값 설정
	return str.length;
}

function foo2(str=''){ // ES6 매개변수 기본값 설정
	return str.length; 
}
```

<br/>

## 옵셔녈 체이닝 연산자

`옵셔널 체이닝 연산자(?.)`는 좌항의 피연산자가 `null `또는 `undefined`인 경우 `undefined`를 반환하고 그렇지 않은 경우에는 우항의 프로퍼티 참조를 이어간다. 즉 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다. 

```javascript
var el = null;
var value = el?.value;
console.log(value); // undefined
```



```
var str = '';
var length = str && str.length; // ''
var length2 = str?.length; // 0
```

&& 연산자는 false로 평가되는 값이면 좌항 피연산자를 그대로 반환하기 때문에 legnth는 ''이 된다. 하지만 옵셔널 체이닝 연산자 ?.는 좌항 피연산자가 false로 평가되더라도 `null` 또는 `undefined`가 아니면 우항의 프로퍼티 참조를 이어간다.

<br/>

## null 병합 연산자

```
var foo = null ?? 'default message'; // 'default message'
var foo = '' ?? 'default message'; // ''
```

null 병합 연산자 ??는 좌항의 피연산자가 `null` 또는 `undefined`인 경우 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다. 위 예제처럼 변수에 기본값을 설정할 때 유용하다.







